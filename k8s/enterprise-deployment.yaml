# Enterprise-Grade HMS Kubernetes Deployment Configuration
# Author: Microservices Scaling Architect
# Purpose: Production-ready scaling configuration for all HMS services

# ==================== CORE SERVICES ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hms-backend
  namespace: hms-production
  labels:
    app: hms-backend
    version: v1.0.0
    tier: backend
    component: core
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
  selector:
    matchLabels:
      app: hms-backend
  template:
    metadata:
      labels:
        app: hms-backend
        version: v1.0.0
        tier: backend
        component: core
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8000"
        prometheus.io/path: "/metrics"
    spec:
      containers:
        - name: hms-backend
          image: hms/backend:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 8000
              name: http
              protocol: TCP
          env:
            - name: DJANGO_SETTINGS_MODULE
              value: "hms.settings.production"
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: database-url
            - name: REDIS_URL
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: redis-url
            - name: SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: django-secret-key
            - name: DEBUG
              value: "False"
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /health/
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /ready/
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 1
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
          volumeMounts:
            - name: config-volume
              mountPath: /app/config
            - name: static-files
              mountPath: /app/static
            - name: media-files
              mountPath: /app/media
      volumes:
        - name: config-volume
          configMap:
            name: hms-config
        - name: static-files
          persistentVolumeClaim:
            claimName: hms-static-pvc
        - name: media-files
          persistentVolumeClaim:
            claimName: hms-media-pvc
      nodeSelector:
        node-role.kubernetes.io/backend: "true"
      tolerations:
        - key: "backend"
          operator: "Equal"
          value: "true"
          effect: "NoSchedule"
---
apiVersion: v1
kind: Service
metadata:
  name: hms-backend-service
  namespace: hms-production
  labels:
    app: hms-backend
    service: hms-backend
spec:
  type: ClusterIP
  selector:
    app: hms-backend
  ports:
    - name: http
      port: 80
      targetPort: 8000
      protocol: TCP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hms-frontend
  namespace: hms-production
  labels:
    app: hms-frontend
    version: v1.0.0
    tier: frontend
    component: ui
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
  selector:
    matchLabels:
      app: hms-frontend
  template:
    metadata:
      labels:
        app: hms-frontend
        version: v1.0.0
        tier: frontend
        component: ui
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "3000"
    spec:
      containers:
        - name: hms-frontend
          image: hms/frontend:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 3000
              name: http
              protocol: TCP
          env:
            - name: REACT_APP_API_URL
              value: "https://api.hms.enterprise"
            - name: REACT_APP_ENVIRONMENT
              value: "production"
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
      nodeSelector:
        node-role.kubernetes.io/frontend: "true"
---
apiVersion: v1
kind: Service
metadata:
  name: hms-frontend-service
  namespace: hms-production
  labels:
    app: hms-frontend
    service: hms-frontend
spec:
  type: ClusterIP
  selector:
    app: hms-frontend
  ports:
    - name: http
      port: 80
      targetPort: 3000
      protocol: TCP

# ==================== DATABASE SCALING ====================
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-primary
  namespace: hms-production
  labels:
    app: postgres
    role: primary
    component: database
spec:
  serviceName: postgres-primary
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      role: primary
  template:
    metadata:
      labels:
        app: postgres
        role: primary
        component: database
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
              name: postgres
          env:
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: postgres-db
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: postgres-user
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: postgres-password
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
          resources:
            requests:
              memory: "2Gi"
              cpu: "1000m"
            limits:
              memory: "4Gi"
              cpu: "2000m"
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
            - name: postgres-config
              mountPath: /etc/postgresql/postgresql.conf
              subPath: postgresql.conf
          livenessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - hms_user
                - -d
                - hms_enterprise
            initialDelaySeconds: 30
            periodSeconds: 10
      volumes:
        - name: postgres-config
          configMap:
            name: postgres-config
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: fast-ssd
        resources:
          requests:
            storage: 100Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-read-replica
  namespace: hms-production
  labels:
    app: postgres
    role: replica
    component: database
spec:
  serviceName: postgres-read-replica
  replicas: 3
  selector:
    matchLabels:
      app: postgres
      role: replica
  template:
    metadata:
      labels:
        app: postgres
        role: replica
        component: database
    spec:
      containers:
        - name: postgres
          image: postgres:15
          ports:
            - containerPort: 5432
              name: postgres
          env:
            - name: POSTGRES_REPLICATION_USER
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: replication-user
            - name: POSTGRES_REPLICATION_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: hms-secrets
                  key: replication-password
            - name: POSTGRES_MASTER_HOST
              value: postgres-primary
            - name: POSTGRES_MASTER_PORT
              value: "5432"
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
    - metadata:
        name: postgres-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: fast-ssd
        resources:
          requests:
            storage: 50Gi

# ==================== REDIS CLUSTER ====================
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: hms-production
  labels:
    app: redis
    component: cache
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
        component: cache
    spec:
      containers:
        - name: redis
          image: redis:7-alpine
          command:
            - redis-server
            - /etc/redis/redis.conf
          ports:
            - containerPort: 6379
              name: redis
          volumeMounts:
            - name: redis-config
              mountPath: /etc/redis
            - name: redis-data
              mountPath: /data
          resources:
            requests:
              memory: "256Mi"
              cpu: "200m"
            limits:
              memory: "1Gi"
              cpu: "500m"
      volumes:
        - name: redis-config
          configMap:
            name: redis-config
  volumeClaimTemplates:
    - metadata:
        name: redis-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: fast-ssd
        resources:
          requests:
            storage: 10Gi

# ==================== API GATEWAY ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kong-api-gateway
  namespace: hms-production
  labels:
    app: kong
    component: gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: kong
  template:
    metadata:
      labels:
        app: kong
        component: gateway
    spec:
      containers:
        - name: kong
          image: kong/kong-gateway:3.4
          env:
            - name: KONG_DATABASE
              value: "off"
            - name: KONG_DECLARATIVE_CONFIG
              value: /etc/kong/kong.yml
            - name: KONG_PROXY_ACCESS_LOG
              value: /dev/stdout
            - name: KONG_ADMIN_ACCESS_LOG
              value: /dev/stdout
            - name: KONG_PROXY_ERROR_LOG
              value: /dev/stderr
            - name: KONG_ADMIN_ERROR_LOG
              value: /dev/stderr
          ports:
            - containerPort: 8000
              name: proxy
            - containerPort: 8443
              name: proxy-ssl
            - containerPort: 8001
              name: admin
          volumeMounts:
            - name: kong-config
              mountPath: /etc/kong
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /status
              port: 8100
            initialDelaySeconds: 10
            periodSeconds: 10
      volumes:
        - name: kong-config
          configMap:
            name: kong-config
---
apiVersion: v1
kind: Service
metadata:
  name: kong-service
  namespace: hms-production
  labels:
    app: kong
    service: kong
spec:
  type: LoadBalancer
  selector:
    app: kong
  ports:
    - name: proxy
      port: 80
      targetPort: 8000
    - name: proxy-ssl
      port: 443
      targetPort: 8443

# ==================== SERVICE MESH (ISTIO) ====================
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: hms-ingress-gateway
  namespace: hms-production
spec:
  selector:
    istio: ingressgateway
  servers:
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - "*"
    - port:
        number: 443
        name: https
        protocol: HTTPS
      tls:
        mode: SIMPLE
        credentialName: hms-tls-secret
      hosts:
        - "*.hms.enterprise"
---
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: hms-virtual-service
  namespace: hms-production
spec:
  hosts:
    - "api.hms.enterprise"
  gateways:
    - hms-ingress-gateway
  http:
    - match:
        - uri:
            prefix: /api/
      route:
        - destination:
            host: hms-backend-service
            port:
              number: 80
    - match:
        - uri:
            prefix: /
      route:
        - destination:
            host: hms-frontend-service
            port:
              number: 80

# ==================== MONITORING STACK ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-server
  namespace: monitoring
  labels:
    app: prometheus
    component: monitoring
spec:
  replicas: 2
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
        component: monitoring
    spec:
      containers:
        - name: prometheus
          image: prom/prometheus:v2.45.0
          args:
            - --storage.tsdb.retention.time=30d
            - --config.file=/etc/prometheus/prometheus.yml
            - --storage.tsdb.path=/prometheus
            - --web.console.libraries=/etc/prometheus/console_libraries
            - --web.console.templates=/etc/prometheus/consoles
            - --web.enable-lifecycle
          ports:
            - containerPort: 9090
          volumeMounts:
            - name: prometheus-config
              mountPath: /etc/prometheus
            - name: prometheus-storage
              mountPath: /prometheus
          resources:
            requests:
              memory: "2Gi"
              cpu: "1000m"
            limits:
              memory: "4Gi"
              cpu: "2000m"
      volumes:
        - name: prometheus-config
          configMap:
            name: prometheus-config
        - name: prometheus-storage
          persistentVolumeClaim:
            claimName: prometheus-pvc
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana-server
  namespace: monitoring
  labels:
    app: grafana
    component: monitoring
spec:
  replicas: 2
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
        component: monitoring
    spec:
      containers:
        - name: grafana
          image: grafana/grafana:10.2.0
          env:
            - name: GF_SECURITY_ADMIN_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: grafana-secrets
                  key: admin-password
            - name: GF_INSTALL_PLUGINS
              value: "grafana-clock-panel,grafana-simple-json-datasource"
          ports:
            - containerPort: 3000
          volumeMounts:
            - name: grafana-storage
              mountPath: /var/lib/grafana
            - name: grafana-config
              mountPath: /etc/grafana
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
      volumes:
        - name: grafana-storage
          persistentVolumeClaim:
            claimName: grafana-pvc
        - name: grafana-config
          configMap:
            name: grafana-config

# ==================== DISTRIBUTED TRACING ====================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger-collector
  namespace: monitoring
  labels:
    app: jaeger
    component: tracing
spec:
  replicas: 2
  selector:
    matchLabels:
      app: jaeger
      component: collector
  template:
    metadata:
      labels:
        app: jaeger
        component: collector
    spec:
      containers:
        - name: jaeger-collector
          image: jaegertracing/jaeger-collector:1.50
          args:
            - --config.file=/etc/jaeger/collector.yaml
          ports:
            - containerPort: 14250
              name: grpc
            - containerPort: 14268
              name: http
          volumeMounts:
            - name: jaeger-config
              mountPath: /etc/jaeger
          resources:
            requests:
              memory: "512Mi"
              cpu: "500m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
      volumes:
        - name: jaeger-config
          configMap:
            name: jaeger-config

# ==================== MESSAGE QUEUE (KAFKA) ====================
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka-broker
  namespace: hms-production
  labels:
    app: kafka
    component: messaging
spec:
  serviceName: kafka-broker
  replicas: 3
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
        component: messaging
    spec:
      containers:
        - name: kafka
          image: confluentinc/cp-kafka:7.4.0
          ports:
            - containerPort: 9092
              name: internal
            - containerPort: 9094
              name: external
          env:
            - name: KAFKA_BROKER_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: KAFKA_ZOOKEEPER_CONNECT
              value: "zookeeper:2181"
            - name: KAFKA_ADVERTISED_LISTENERS
              value: "INTERNAL://kafka-broker-0.kafka-broker.hms-production.svc.cluster.local:9092,EXTERNAL://localhost:9094"
            - name: KAFKA_LISTENER_SECURITY_PROTOCOL_MAP
              value: "INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT"
            - name: KAFKA_INTER_BROKER_LISTENER_NAME
              value: "INTERNAL"
            - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
              value: "3"
            - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
              value: "3"
            - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
              value: "2"
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "2Gi"
              cpu: "1000m"
          volumeMounts:
            - name: kafka-data
              mountPath: /var/lib/kafka/data
  volumeClaimTemplates:
    - metadata:
        name: kafka-data
      spec:
        accessModes: ["ReadWriteOnce"]
        storageClassName: fast-ssd
        resources:
          requests:
            storage: 50Gi