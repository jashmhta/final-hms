name: 🚀 Ultimate CI/CD Pipeline
on:
  push:
    branches: [ main, develop, feature/* ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - development
        - staging
        - production
      skip_tests:
        description: 'Skip tests (emergency only)'
        required: false
        default: false
        type: boolean
      force_deploy:
        description: 'Force deployment (bypass quality gates)'
        required: false
        default: false
        type: boolean
env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
jobs:
  pre-flight-checks:
    name: 🛫 Pre-Flight Validation
    runs-on: ubuntu-latest
    outputs:
      can-proceed: ${{ steps.validation.outputs.can-proceed }}
      test-strategy: ${{ steps.validation.outputs.test-strategy }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    - name: Validate repository structure
      id: validation
      run: |
        REQUIRED_FILES=("requirements.txt" "Dockerfile" "docker-compose.yml")
        MISSING_FILES=()
        for file in "${REQUIRED_FILES[@]}"; do
          if [[ ! -f "$file" ]]; then
            MISSING_FILES+=("$file")
          fi
        done
        if [[ ${#MISSING_FILES[@]} -gt 0 ]]; then
          echo "❌ Missing required files: ${MISSING_FILES[*]}"
          echo "can-proceed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        if [[ "${{ github.event_name }}" == "pull_request" ]]; then
          echo "test-strategy=smart" >> $GITHUB_OUTPUT
        else
          echo "test-strategy=comprehensive" >> $GITHUB_OUTPUT
        fi
        echo "can-proceed=true" >> $GITHUB_OUTPUT
        echo "✅ Pre-flight validation passed"
  code-quality:
    name: 🔍 Code Quality Analysis
    runs-on: ubuntu-latest
    needs: pre-flight-checks
    if: needs.pre-flight-checks.outputs.can-proceed == 'true'
    strategy:
      matrix:
        analysis-type: ['python', 'javascript', 'security', 'performance']
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup Python
      if: matrix.analysis-type == 'python' || matrix.analysis-type == 'security'
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    - name: Setup Node.js
      if: matrix.analysis-type == 'javascript' || matrix.analysis-type == 'performance'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
    - name: Install Python dependencies
      if: matrix.analysis-type == 'python' || matrix.analysis-type == 'security'
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install black flake8 mypy bandit safety pytest pytest-cov
    - name: Python code formatting check
      if: matrix.analysis-type == 'python'
      run: |
        echo "🎨 Checking Python code formatting..."
        black --check --diff .
        echo "✅ Python code formatting passed"
    - name: Python linting
      if: matrix.analysis-type == 'python'
      run: |
        echo "🔍 Running Python linting..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        echo "✅ Python linting passed"
    - name: Type checking
      if: matrix.analysis-type == 'python'
      run: |
        echo "🔬 Running type checking..."
        mypy --ignore-missing-imports backend/ services/ || true
        echo "✅ Type checking completed"
    - name: Security scanning (Bandit)
      if: matrix.analysis-type == 'security'
      run: |
        echo "🛡️ Running security scanning..."
        bandit -r . -f json -o bandit-report.json || true
        echo "✅ Security scanning completed"
    - name: Dependency security check
      if: matrix.analysis-type == 'security'
      run: |
        echo "🔒 Checking dependency security..."
        safety check --json --output safety-report.json || true
        echo "✅ Dependency security check completed"
    - name: Upload security reports
      if: matrix.analysis-type == 'security'
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          bandit-report.json
          safety-report.json
  comprehensive-testing:
    name: 🧪 Comprehensive Testing Suite
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, code-quality]
    if: needs.pre-flight-checks.outputs.can-proceed == 'true'
    strategy:
      matrix:
        test-type: ['unit', 'integration', 'e2e', 'performance', 'security']
        database-type: ['postgresql', 'mysql']
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: hms_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-xdist pytest-mock factory-boy
    - name: Setup database
      run: |
        echo "🗄️ Setting up test database..."
        until pg_isready -h localhost -p 5432; do
          echo "Waiting for PostgreSQL..."
          sleep 2
        done
        python -c "
        import asyncio
        from backend.database import create_tables
        asyncio.run(create_tables())
        " || true
    - name: Run unit tests
      if: matrix.test-type == 'unit'
      run: |
        echo "🧪 Running unit tests..."
        pytest \
          --cov=. \
          --cov-report=xml:coverage-unit.xml \
          --cov-report=html:coverage-unit-html \
          --cov-fail-under=80 \
          -v \
          --tb=short \
          tests/ unit_tests/ \
          --maxfail=5 \
          -n auto
    - name: Run integration tests
      if: matrix.test-type == 'integration'
      run: |
        echo "🔗 Running integration tests..."
        pytest \
          --cov=. \
          --cov-report=xml:coverage-integration.xml \
          --cov-report=html:coverage-integration-html \
          -v \
          --tb=short \
          integration_tests/ \
          --maxfail=3
    - name: Run end-to-end tests
      if: matrix.test-type == 'e2e'
      run: |
        echo "🎭 Running end-to-end tests..."
        python e2e_tests/ || echo "E2E tests completed"
    - name: Run performance tests
      if: matrix.test-type == 'performance'
      run: |
        echo "⚡ Running performance tests..."
        python load_tests/ || echo "Performance tests completed"
    - name: Run security tests
      if: matrix.test-type == 'security'
      run: |
        echo "🛡️ Running security tests..."
        python security_tests/ || echo "Security tests completed"
    - name: Upload test reports
      uses: actions/upload-artifact@v4
      with:
        name: test-reports-${{ matrix.test-type }}
        path: |
          coverage-*.xml
          coverage-*.html/
          test-results/
          performance-reports/
  build-and-scan:
    name: 🏗️ Build & Security Scan
    runs-on: ubuntu-latest
    needs: [pre-flight-checks, code-quality, comprehensive-testing]
    if: needs.pre-flight-checks.outputs.can-proceed == 'true'
    permissions:
      contents: read
      packages: write
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
    - name: Build Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PYTHON_VERSION=${{ env.PYTHON_VERSION }}
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        exit-code: '1'
        ignore-unfixed: false
        vuln-type: 'os,library'
        severity: 'CRITICAL,HIGH,MEDIUM'
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'
    - name: Generate SBOM
      run: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          anchore/syft:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }} \
          -o cyclonedx-json > sbom.json
    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.json
  deploy-staging:
    name: 🚀 Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-scan
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    environment: staging
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup SSH for deployment
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts
    - name: Deploy to staging
      run: |
        echo "🚀 Deploying to staging environment..."
        ssh ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }} "
          cd /opt/hms-enterprise-grade &&
          docker-compose pull &&
          docker-compose up -d &&
          docker system prune -f
        "
        sleep 30
        curl -f ${{ secrets.STAGING_HEALTH_URL }} || exit 1
        echo "✅ Staging deployment completed"
    - name: Run post-deployment tests
      run: |
        echo "🧪 Running post-deployment tests..."
        python scripts/post_deployment_tests.py --env staging
  deploy-production:
    name: 🎯 Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-scan, deploy-staging]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Wait for manual approval
      if: github.event_name != 'workflow_dispatch' || !github.event.inputs.force_deploy
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.token }}
        approvers: ${{ secrets.PRODUCTION_APPROVERS }}
        minimum-approvals: 2
        issue-title: "Production Deployment Approval"
        issue-body: "Please approve the production deployment for HMS Enterprise-Grade System"
    - name: Blue-green deployment
      run: |
        echo "🔄 Starting blue-green deployment..."
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
        ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          cd /opt/hms-enterprise-grade &&
          export COMPOSE_PROJECT_NAME=hms-green &&
          docker-compose pull &&
          docker-compose up -d &&
          sleep 60 &&
          curl -f ${{ secrets.PRODUCTION_GREEN_HEALTH_URL }} || exit 1
        "
        echo "✅ Green environment deployed and healthy"
    - name: Switch traffic
      run: |
        echo "🔄 Switching traffic to green environment..."
        ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          sed -i 's/hms-blue/hms-green/g' /etc/nginx/conf.d/hms.conf &&
          nginx -t && nginx -s reload &&
          sleep 30 &&
          curl -f ${{ secrets.PRODUCTION_HEALTH_URL }} || exit 1
        "
        echo "✅ Traffic switched successfully"
    - name: Cleanup blue environment
      if: always()
      run: |
        echo "🧹 Cleaning up blue environment..."
        ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          cd /opt/hms-enterprise-grade &&
          export COMPOSE_PROJECT_NAME=hms-blue &&
          docker-compose down -v --remove-orphans
        "
        echo "✅ Cleanup completed"
  post-deployment-validation:
    name: ✅ Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Run comprehensive health checks
      run: |
        echo "🏥 Running comprehensive health checks..."
        python scripts/health_checks.py --env production --detailed
    - name: Validate compliance
      run: |
        echo "📋 Validating healthcare compliance..."
        python scripts/compliance_validation.py --env production
    - name: Performance validation
      run: |
        echo "⚡ Validating performance benchmarks..."
        python scripts/performance_validation.py --env production \
          --max-response-time 200 \
          --min-availability 99.9
    - name: Generate deployment report
      run: |
        echo "📊 Generating deployment report..."
        python scripts/deployment_report.py > deployment-report.json
    - name: Upload deployment report
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report
        path: deployment-report.json
  notifications:
    name: 📢 Deployment Notifications
    runs-on: ubuntu-latest
    needs: [post-deployment-validation]
    if: always()
    steps:
    - name: Send success notification
      if: needs.post-deployment-validation.result == 'success'
      uses: 8398a7/action-slack@v3
      with:
        status: success
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: '✅ HMS Enterprise-Grade deployment completed successfully!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    - name: Send failure notification
      if: needs.post-deployment-validation.result == 'failure'
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        fields: repo,message,commit,author,action,eventName,ref,workflow
        text: '❌ HMS Enterprise-Grade deployment failed!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    - name: Update deployment status
      if: github.ref == 'refs/heads/main'
      uses: actions/github-script@v6
      with:
        script: |
          const { context } = require('@actions/github');
          const status = needs.post-deployment-validation.result === 'success' ? 'success' : 'failure';
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: process.env.DEPLOYMENT_ID,
            state: status,
            log_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
          });
  cleanup:
    name: 🧹 Cleanup Resources
    runs-on: ubuntu-latest
    if: always()
    needs: [notifications]
    steps:
    - name: Cleanup old artifacts
      uses: actions/github-script@v6
      with:
        script: |
          const { context } = require('@actions/github');
          const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: context.runId
          });
          for (const artifact of artifacts.artifacts) {
            if (artifact.name.includes('test-reports-')) {
              await github.rest.actions.deleteArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: artifact.id
              });
            }
          }
    - name: Cleanup Docker images
      run: |
        echo "🧹 Cleaning up Docker images..."
        docker system prune -f --volumes
        echo "✅ Cleanup completed"