#!/usr/bin/env python3
"""
HMS Enterprise-Grade Vulnerability Management System
Comprehensive vulnerability tracking, prioritization, and remediation workflow
"""

import os
import sys
import json
import yaml
import logging
import hashlib
import requests
import smtplib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, asdict, field
from enum import Enum
from pathlib import Path
import boto3
from botocore.exceptions import ClientError
import jira
from jira import JIRA
import pandas as pd
import numpy as np
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Text, Boolean, Float, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.dialects.postgresql import UUID, JSONB

Base = declarative_base()

class VulnerabilityStatus(Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    CLOSED = "closed"
    FALSE_POSITIVE = "false_positive"
    ACCEPTED_RISK = "accepted_risk"
    REJECTED = "rejected"

class Priority(Enum):
    CRITICAL = 1
    HIGH = 2
    MEDIUM = 3
    LOW = 4
    INFO = 5

class RemediationStatus(Enum):
    NOT_STARTED = "not_started"
    PLANNED = "planned"
    IN_DEVELOPMENT = "in_development"
    TESTING = "testing"
    DEPLOYED = "deployed"
    VERIFIED = "verified"

@dataclass
class CVSSScore:
    base_score: float
    impact_score: float
    exploitability_score: float
    temporal_score: Optional[float] = None
    environmental_score: Optional[float] = None
    vector_string: Optional[str] = None

@dataclass
class Vulnerability:
    id: str
    title: str
    description: str
    severity: Priority
    cvss_score: Optional[CVSSScore]
    category: str
    scanner: str
    location: str
    status: VulnerabilityStatus
    first_detected: datetime
    last_detected: datetime
    affected_components: List[str]
    remediation: str
    assignee: Optional[str]
    due_date: Optional[datetime]
    jira_ticket: Optional[str]
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class RemediationPlan:
    vulnerability_id: str
    steps: List[str]
    estimated_effort_hours: float
    complexity: str  # "low", "medium", "high"
    dependencies: List[str]
    rollout_strategy: str  # "immediate", "scheduled", "phased"
    rollback_plan: str
    verification_steps: List[str]

class VulnerabilityDatabase:
    """PostgreSQL database for vulnerability management"""

    def __init__(self, db_url: str):
        self.engine = create_engine(db_url)
        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)
        Base.metadata.create_all(bind=self.engine)

    def get_session(self):
        return self.SessionLocal()

class VulnerabilityModel(Base):
    __tablename__ = "vulnerabilities"

    id = Column(String(64), primary_key=True)
    title = Column(String(500), nullable=False)
    description = Column(Text, nullable=False)
    severity = Column(String(20), nullable=False)
    cvss_base_score = Column(Float)
    cvss_vector = Column(String(200))
    category = Column(String(100), nullable=False)
    scanner = Column(String(100), nullable=False)
    location = Column(String(1000), nullable=False)
    status = Column(String(50), nullable=False, default="open")
    first_detected = Column(DateTime, nullable=False)
    last_detected = Column(DateTime, nullable=False)
    affected_components = Column(JSONB)
    remediation = Column(Text)
    assignee = Column(String(200))
    due_date = Column(DateTime)
    jira_ticket = Column(String(50))
    tags = Column(JSONB)
    metadata = Column(JSONB)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class RemediationPlanModel(Base):
    __tablename__ = "remediation_plans"

    id = Column(String(64), primary_key=True)
    vulnerability_id = Column(String(64), ForeignKey("vulnerabilities.id"))
    steps = Column(JSONB, nullable=False)
    estimated_effort_hours = Column(Float, nullable=False)
    complexity = Column(String(20), nullable=False)
    dependencies = Column(JSONB)
    rollout_strategy = Column(String(50), nullable=False)
    rollback_plan = Column(Text, nullable=False)
    verification_steps = Column(JSONB, nullable=False)
    status = Column(String(50), default="not_started")
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    vulnerability = relationship("VulnerabilityModel", back_populates="remediation_plan")

VulnerabilityModel.remediation_plan = relationship("RemediationPlanModel", back_populates="vulnerability", uselist=False)

class HMSVulnerabilityManager:
    """Enterprise-grade vulnerability management for healthcare systems"""

    def __init__(self, config_path: str = "devops/security/vulnerability-config.yaml"):
        self.config = self._load_config(config_path)
        self.logger = self._setup_logging()
        self.db = VulnerabilityDatabase(self.config["database"]["url"])

        # Initialize integrations
        self._init_jira()
        self._init_aws_services()
        self._init_notification_services()

        # Business logic for healthcare vulnerability prioritization
        self.healthcare_risk_factors = {
            "phi_data_exposure": 10.0,
            "authentication_bypass": 9.5,
            "authorization_bypass": 9.0,
            "data_encryption_failure": 8.5,
            "audit_trail_failure": 8.0,
            "injection": 8.5,
            "xss": 7.5,
            "csrf": 7.0,
            "ssrf": 7.5,
            "file_upload": 7.0
        }

    def _load_config(self, config_path: str) -> Dict:
        """Load vulnerability management configuration"""
        try:
            with open(config_path, 'r') as f:
                return yaml.safe_load(f)
        except FileNotFoundError:
            return self._get_default_config()

    def _get_default_config(self) -> Dict:
        """Get default vulnerability management configuration"""
        return {
            "database": {
                "url": "postgresql://user:password@localhost/hms_vulnerabilities"
            },
            "jira": {
                "enabled": True,
                "server": "https://hms-enterprise.atlassian.net",
                "project_key": "VULN",
                "assignee": "security-team"
            },
            "aws": {
                "enabled": True,
                "security_hub": True,
                "region": "us-east-1"
            },
            "notifications": {
                "enabled": True,
                "slack_webhook": os.getenv("SLACK_VULN_WEBHOOK"),
                "email_enabled": True,
                "smtp_server": "smtp.hms-enterprise.com",
                "email_from": "vulnerability-manager@hms-enterprise.com"
            },
            "prioritization": {
                "healthcare_critical": True,
                "data_classification_weight": 2.0,
                "compliance_weight": 1.5,
                "exploitability_weight": 1.0
            },
            "workflow": {
                "auto_create_tickets": True,
                "auto_assign": True,
                "sla_critical_hours": 24,
                "sla_high_hours": 72,
                "sla_medium_hours": 168,
                "sla_low_hours": 336
            }
        }

    def _setup_logging(self) -> logging.Logger:
        """Setup logging for vulnerability management"""
        logger = logging.getLogger('hms_vulnerability_manager')
        logger.setLevel(logging.INFO)

        # Create formatters
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'
        )

        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(formatter)

        # File handler
        file_handler = logging.FileHandler('/var/log/hms/vulnerability-management.log')
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)

        logger.addHandler(console_handler)
        logger.addHandler(file_handler)

        return logger

    def _init_jira(self):
        """Initialize JIRA integration"""
        if self.config["jira"]["enabled"]:
            try:
                self.jira_client = JIRA(
                    server=self.config["jira"]["server"],
                    basic_auth=(os.getenv("JIRA_USERNAME"), os.getenv("JIRA_API_TOKEN"))
                )
                self.logger.info("JIRA integration initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize JIRA: {e}")
                self.jira_client = None

    def _init_aws_services(self):
        """Initialize AWS service integrations"""
        if self.config["aws"]["enabled"]:
            try:
                self.security_hub = boto3.client('securityhub')
                self.sns = boto3.client('sns')
                self.sqs = boto3.client('sqs')
                self.logger.info("AWS services initialized")
            except Exception as e:
                self.logger.error(f"Failed to initialize AWS services: {e}")

    def _init_notification_services(self):
        """Initialize notification services"""
        self.slack_webhook = self.config["notifications"]["slack_webhook"]
        self.email_enabled = self.config["notifications"]["email_enabled"]

    def ingest_vulnerabilities(self, scan_results: List[Dict]) -> List[Vulnerability]:
        """Ingest vulnerability findings from security scans"""
        ingested_vulnerabilities = []

        for scan_result in scan_results:
            for vuln_data in scan_result.get("vulnerabilities", []):
                vulnerability = self._parse_vulnerability(vuln_data, scan_result)
                existing_vuln = self._find_existing_vulnerability(vulnerability)

                if existing_vuln:
                    # Update existing vulnerability
                    self._update_vulnerability(existing_vuln, vulnerability)
                    ingested_vulnerabilities.append(existing_vuln)
                else:
                    # Create new vulnerability
                    self._create_vulnerability(vulnerability)
                    ingested_vulnerabilities.append(vulnerability)

        return ingested_vulnerabilities

    def _parse_vulnerability(self, vuln_data: Dict, scan_result: Dict) -> Vulnerability:
        """Parse vulnerability data from scan results"""
        return Vulnerability(
            id=self._generate_vulnerability_id(vuln_data),
            title=vuln_data.get("title", "Unknown Vulnerability"),
            description=vuln_data.get("description", ""),
            severity=self._map_severity(vuln_data.get("severity", "medium")),
            cvss_score=self._parse_cvss_score(vuln_data.get("cvss_score")),
            category=vuln_data.get("category", "Unknown"),
            scanner=scan_result.get("scanner_name", "Unknown"),
            location=vuln_data.get("location", ""),
            status=VulnerabilityStatus.OPEN,
            first_detected=datetime.now(),
            last_detected=datetime.now(),
            affected_components=vuln_data.get("affected_components", []),
            remediation=vuln_data.get("remediation", ""),
            assignee=None,
            due_date=None,
            jira_ticket=None,
            tags=vuln_data.get("tags", []),
            metadata={
                "source_scan": scan_result.get("scan_type"),
                "raw_data": vuln_data
            }
        )

    def _generate_vulnerability_id(self, vuln_data: Dict) -> str:
        """Generate unique vulnerability ID"""
        content = f"{vuln_data.get('title', '')}{vuln_data.get('location', '')}{vuln_data.get('category', '')}"
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def _find_existing_vulnerability(self, vulnerability: Vulnerability) -> Optional[Vulnerability]:
        """Find existing vulnerability by hash"""
        session = self.db.get_session()
        try:
            db_vuln = session.query(VulnerabilityModel).filter_by(id=vulnerability.id).first()
            if db_vuln:
                return self._db_model_to_vulnerability(db_vuln)
            return None
        finally:
            session.close()

    def _create_vulnerability(self, vulnerability: Vulnerability):
        """Create new vulnerability in database"""
        session = self.db.get_session()
        try:
            db_vuln = VulnerabilityModel(
                id=vulnerability.id,
                title=vulnerability.title,
                description=vulnerability.description,
                severity=vulnerability.severity.value,
                cvss_base_score=vulnerability.cvss_score.base_score if vulnerability.cvss_score else None,
                cvss_vector=vulnerability.cvss_score.vector_string if vulnerability.cvss_score else None,
                category=vulnerability.category,
                scanner=vulnerability.scanner,
                location=vulnerability.location,
                status=vulnerability.status.value,
                first_detected=vulnerability.first_detected,
                last_detected=vulnerability.last_detected,
                affected_components=vulnerability.affected_components,
                remediation=vulnerability.remediation,
                tags=vulnerability.tags,
                metadata=vulnerability.metadata
            )
            session.add(db_vuln)
            session.commit()

            # Create remediation plan
            remediation_plan = self._generate_remediation_plan(vulnerability)
            self._create_remediation_plan(db_vuln.id, remediation_plan)

            # Create JIRA ticket if enabled
            if self.config["jira"]["enabled"] and self.jira_client:
                jira_ticket = self._create_jira_ticket(vulnerability)
                if jira_ticket:
                    db_vuln.jira_ticket = jira_ticket
                    session.commit()

            # Send notifications
            self._send_vulnerability_notification(vulnerability, "new")

            self.logger.info(f"Created new vulnerability: {vulnerability.id}")

        except Exception as e:
            session.rollback()
            self.logger.error(f"Failed to create vulnerability {vulnerability.id}: {e}")
            raise
        finally:
            session.close()

    def _update_vulnerability(self, existing_vuln: Vulnerability, new_vuln: Vulnerability):
        """Update existing vulnerability with new scan data"""
        session = self.db.get_session()
        try:
            db_vuln = session.query(VulnerabilityModel).filter_by(id=existing_vuln.id).first()
            if db_vuln:
                db_vuln.last_detected = new_vuln.last_detected
                db_vuln.metadata.update(new_vuln.metadata)
                session.commit()

                # Check if vulnerability is still relevant
                if db_vuln.status == "resolved" and new_vuln.status == "open":
                    self._handle_vulnerability_regression(existing_vuln)
                    self._send_vulnerability_notification(existing_vuln, "regression")

        except Exception as e:
            session.rollback()
            self.logger.error(f"Failed to update vulnerability {existing_vuln.id}: {e}")
            raise
        finally:
            session.close()

    def prioritize_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Prioritize vulnerabilities using healthcare-specific risk scoring"""
        for vuln in vulnerabilities:
            risk_score = self._calculate_risk_score(vuln)
            vuln.metadata["risk_score"] = risk_score

            # Adjust priority based on healthcare context
            adjusted_priority = self._adjust_priority_for_healthcare(vuln, risk_score)
            vuln.metadata["adjusted_priority"] = adjusted_priority

            # Set due date based on SLA
            vuln.due_date = self._calculate_due_date(vuln)

        # Sort by risk score
        return sorted(vulnerabilities, key=lambda x: x.metadata.get("risk_score", 0), reverse=True)

    def _calculate_risk_score(self, vulnerability: Vulnerability) -> float:
        """Calculate risk score for vulnerability"""
        base_score = 0.0

        # CVSS score weight (40%)
        if vulnerability.cvss_score:
            base_score += vulnerability.cvss_score.base_score * 0.4

        # Severity weight (30%)
        severity_scores = {
            Priority.CRITICAL: 10.0,
            Priority.HIGH: 8.0,
            Priority.MEDIUM: 5.0,
            Priority.LOW: 2.0,
            Priority.INFO: 0.5
        }
        base_score += severity_scores.get(vulnerability.severity, 0) * 0.3

        # Healthcare-specific risk factors (20%)
        healthcare_score = 0.0
        for factor, score in self.healthcare_risk_factors.items():
            if factor.lower() in vulnerability.title.lower() or factor.lower() in vulnerability.description.lower():
                healthcare_score = max(healthcare_score, score)
        base_score += healthcare_score * 0.2

        # Exploitability (10%)
        exploitability = self._assess_exploitability(vulnerability)
        base_score += exploitability * 0.1

        return min(base_score, 10.0)

    def _adjust_priority_for_healthcare(self, vulnerability: Vulnerability, risk_score: float) -> Priority:
        """Adjust priority based on healthcare context"""
        # Critical healthcare vulnerabilities get highest priority
        if any(keyword in vulnerability.title.lower() for keyword in ["phi", "patient", "medical", "health"]):
            if risk_score >= 8.0:
                return Priority.CRITICAL
            elif risk_score >= 6.0:
                return Priority.HIGH

        # Normal priority mapping
        if risk_score >= 9.0:
            return Priority.CRITICAL
        elif risk_score >= 7.0:
            return Priority.HIGH
        elif risk_score >= 4.0:
            return Priority.MEDIUM
        elif risk_score >= 2.0:
            return Priority.LOW
        else:
            return Priority.INFO

    def _assess_exploitability(self, vulnerability: Vulnerability) -> float:
        """Assess exploitability of vulnerability"""
        exploitability_score = 0.0

        # Check for known exploits
        if "known_exploit" in vulnerability.metadata:
            exploitability_score += 5.0

        # Check for public exploit code
        if "public_exploit" in vulnerability.metadata:
            exploitability_score += 3.0

        # Check for ease of exploitation
        if "authentication_required" not in vulnerability.metadata:
            exploitability_score += 2.0

        return min(exploitability_score, 10.0)

    def _calculate_due_date(self, vulnerability: Vulnerability) -> datetime:
        """Calculate due date based on SLA and priority"""
        sla_hours = {
            Priority.CRITICAL: self.config["workflow"]["sla_critical_hours"],
            Priority.HIGH: self.config["workflow"]["sla_high_hours"],
            Priority.MEDIUM: self.config["workflow"]["sla_medium_hours"],
            Priority.LOW: self.config["workflow"]["sla_low_hours"]
        }

        hours = sla_hours.get(vulnerability.severity, 168)  # Default to 1 week
        return datetime.now() + timedelta(hours=hours)

    def _generate_remediation_plan(self, vulnerability: Vulnerability) -> RemediationPlan:
        """Generate remediation plan for vulnerability"""
        plans = {
            "injection": {
                "steps": [
                    "Review all input validation",
                    "Implement parameterized queries",
                    "Add output encoding",
                    "Test with OWASP ZAP"
                ],
                "effort": 8.0,
                "complexity": "medium"
            },
            "xss": {
                "steps": [
                    "Implement input sanitization",
                    "Add CSP headers",
                    "Enable auto-escaping",
                    "Test with browser dev tools"
                ],
                "effort": 4.0,
                "complexity": "low"
            },
            "authentication": {
                "steps": [
                    "Review authentication logic",
                    "Implement MFA",
                    "Add session timeout",
                    "Test with various scenarios"
                ],
                "effort": 16.0,
                "complexity": "high"
            }
        }

        default_plan = {
            "steps": [
                "Analyze vulnerability impact",
                "Develop fix",
                "Test fix in staging",
                "Deploy to production",
                "Verify fix effectiveness"
            ],
            "effort": 4.0,
            "complexity": "medium"
        }

        # Find matching plan
        category_key = vulnerability.category.lower()
        plan_data = plans.get(category_key, default_plan)

        return RemediationPlan(
            vulnerability_id=vulnerability.id,
            steps=plan_data["steps"],
            estimated_effort_hours=plan_data["effort"],
            complexity=plan_data["complexity"],
            dependencies=[],
            rollout_strategy="scheduled",
            rollback_plan="Revert to previous version if issues occur",
            verification_steps=[
                "Re-run security scan",
                "Manual testing",
                "Regression testing"
            ]
        )

    def _create_remediation_plan(self, vulnerability_id: str, plan: RemediationPlan):
        """Create remediation plan in database"""
        session = self.db.get_session()
        try:
            db_plan = RemediationPlanModel(
                id=f"plan-{vulnerability_id}",
                vulnerability_id=vulnerability_id,
                steps=plan.steps,
                estimated_effort_hours=plan.estimated_effort_hours,
                complexity=plan.complexity,
                dependencies=plan.dependencies,
                rollout_strategy=plan.rollout_strategy,
                rollback_plan=plan.rollback_plan,
                verification_steps=plan.verification_steps
            )
            session.add(db_plan)
            session.commit()
        except Exception as e:
            session.rollback()
            self.logger.error(f"Failed to create remediation plan for {vulnerability_id}: {e}")
        finally:
            session.close()

    def _create_jira_ticket(self, vulnerability: Vulnerability) -> Optional[str]:
        """Create JIRA ticket for vulnerability"""
        if not self.jira_client:
            return None

        try:
            priority_map = {
                Priority.CRITICAL: "Highest",
                Priority.HIGH: "High",
                Priority.MEDIUM: "Medium",
                Priority.LOW: "Low",
                Priority.INFO: "Lowest"
            }

            issue_dict = {
                'project': {'key': self.config["jira"]["project_key"]},
                'summary': f"[Security] {vulnerability.title}",
                'description': self._generate_jira_description(vulnerability),
                'issuetype': {'name': 'Bug'},
                'priority': {'name': priority_map.get(vulnerability.severity, "Medium")},
                'labels': ['security', vulnerability.category.lower()],
                'duedate': vulnerability.due_date.strftime('%Y-%m-%d') if vulnerability.due_date else None
            }

            if self.config["workflow"]["auto_assign"]:
                issue_dict['assignee'] = {'name': self.config["jira"]["assignee"]}

            issue = self.jira_client.create_issue(fields=issue_dict)
            return issue.key

        except Exception as e:
            self.logger.error(f"Failed to create JIRA ticket for {vulnerability.id}: {e}")
            return None

    def _generate_jira_description(self, vulnerability: Vulnerability) -> str:
        """Generate JIRA ticket description"""
        description = f"""
*Vulnerability Details:*
- *Title:* {vulnerability.title}
- *Severity:* {vulnerability.severity.value}
- *Category:* {vulnerability.category}
- *Scanner:* {vulnerability.scanner}
- *Location:* {vulnerability.location}
- *First Detected:* {vulnerability.first_detected.strftime('%Y-%m-%d %H:%M:%S')}

*Description:*
{vulnerability.description}

*Remediation:*
{vulnerability.remediation}

*CVSS Score:* {vulnerability.cvss_score.base_score if vulnerability.cvss_score else 'N/A'}

*Affected Components:*
{chr(10).join(f'- {comp}' for comp in vulnerability.affected_components)}

*Metadata:*
{json.dumps(vulnerability.metadata, indent=2)}

---
ðŸ¤– Generated with [Claude Code](https://claude.ai/code)
"""
        return description

    def _send_vulnerability_notification(self, vulnerability: Vulnerability, notification_type: str):
        """Send vulnerability notifications"""
        if not self.config["notifications"]["enabled"]:
            return

        # Send Slack notification
        if self.slack_webhook:
            self._send_slack_notification(vulnerability, notification_type)

        # Send email notification
        if self.email_enabled:
            self._send_email_notification(vulnerability, notification_type)

    def _send_slack_notification(self, vulnerability: Vulnerability, notification_type: str):
        """Send Slack notification"""
        try:
            severity_colors = {
                Priority.CRITICAL: "#ff0000",
                Priority.HIGH: "#ff9900",
                Priority.MEDIUM: "#ffcc00",
                Priority.LOW: "#00cc00",
                Priority.INFO: "#0066cc"
            }

            icons = {
                "new": "ðŸš¨",
                "regression": "ðŸ”„",
                "resolved": "âœ…",
                "closed": "ðŸ”’"
            }

            payload = {
                "text": f"{icons.get(notification_type, 'ðŸ”')} Vulnerability {notification_type.replace('_', ' ').title()}: {vulnerability.title}",
                "attachments": [
                    {
                        "color": severity_colors.get(vulnerability.severity, "#cccccc"),
                        "title": vulnerability.title,
                        "title_link": f"https://hms-enterprise.atlassian.net/browse/{vulnerability.jira_ticket}" if vulnerability.jira_ticket else None,
                        "text": vulnerability.description[:200] + "..." if len(vulnerability.description) > 200 else vulnerability.description,
                        "fields": [
                            {
                                "title": "Severity",
                                "value": vulnerability.severity.value.upper(),
                                "short": True
                            },
                            {
                                "title": "Category",
                                "value": vulnerability.category,
                                "short": True
                            },
                            {
                                "title": "Scanner",
                                "value": vulnerability.scanner,
                                "short": True
                            },
                            {
                                "title": "Due Date",
                                "value": vulnerability.due_date.strftime('%Y-%m-%d') if vulnerability.due_date else "Not set",
                                "short": True
                            }
                        ],
                        "footer": "HMS Security Team",
                        "ts": int(datetime.now().timestamp())
                    }
                ]
            }

            requests.post(self.slack_webhook, json=payload, timeout=10)

        except Exception as e:
            self.logger.error(f"Failed to send Slack notification: {e}")

    def _send_email_notification(self, vulnerability: Vulnerability, notification_type: str):
        """Send email notification"""
        # Implementation for email notifications
        pass

    def generate_vulnerability_report(self, days: int = 30) -> Dict:
        """Generate vulnerability management report"""
        session = self.db.get_session()
        try:
            # Get vulnerabilities from last N days
            start_date = datetime.now() - timedelta(days=days)
            vulnerabilities = session.query(VulnerabilityModel).filter(
                VulnerabilityModel.first_detected >= start_date
            ).all()

            # Calculate statistics
            total_vulns = len(vulnerabilities)
            severity_counts = {}
            status_counts = {}

            for vuln in vulnerabilities:
                severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
                status_counts[vuln.status] = status_counts.get(vuln.status, 0) + 1

            # Calculate SLA compliance
            sla_compliance = self._calculate_sla_compliance(vulnerabilities)

            # Calculate risk trends
            risk_trends = self._calculate_risk_trends(vulnerabilities)

            report = {
                "report_metadata": {
                    "period_days": days,
                    "generated_at": datetime.now().isoformat(),
                    "total_vulnerabilities": total_vulns
                },
                "severity_breakdown": severity_counts,
                "status_breakdown": status_counts,
                "sla_compliance": sla_compliance,
                "risk_trends": risk_trends,
                "top_vulnerabilities": self._get_top_vulnerabilities(vulnerabilities, 10),
                "compliance_summary": self._generate_compliance_summary(vulnerabilities),
                "recommendations": self._generate_recommendations(vulnerabilities)
            }

            return report

        finally:
            session.close()

    def _calculate_sla_compliance(self, vulnerabilities: List[VulnerabilityModel]) -> Dict:
        """Calculate SLA compliance metrics"""
        sla_compliance = {}
        current_time = datetime.now()

        for severity in ["critical", "high", "medium", "low"]:
            vulns_of_severity = [v for v in vulnerabilities if v.severity == severity]

            if not vulns_of_severity:
                continue

            # Calculate SLA hours
            sla_hours_map = {
                "critical": self.config["workflow"]["sla_critical_hours"],
                "high": self.config["workflow"]["sla_high_hours"],
                "medium": self.config["workflow"]["sla_medium_hours"],
                "low": self.config["workflow"]["sla_low_hours"]
            }
            sla_hours = sla_hours_map.get(severity, 168)

            # Check compliance
            compliant_count = 0
            for vuln in vulns_of_severity:
                if vuln.status in ["resolved", "closed"]:
                    time_to_resolve = (vuln.updated_at - vuln.first_detected).total_seconds() / 3600
                    if time_to_resolve <= sla_hours:
                        compliant_count += 1

            compliance_rate = (compliant_count / len(vulns_of_severity)) * 100 if vulns_of_severity else 0

            sla_compliance[severity] = {
                "total_count": len(vulns_of_severity),
                "compliant_count": compliant_count,
                "compliance_rate": round(compliance_rate, 2),
                "sla_hours": sla_hours
            }

        return sla_compliance

    def _get_top_vulnerabilities(self, vulnerabilities: List[VulnerabilityModel], limit: int) -> List[Dict]:
        """Get top vulnerabilities by risk score"""
        vuln_list = [self._db_model_to_vulnerability(v) for v in vulnerabilities]
        vuln_list.sort(key=lambda x: x.metadata.get("risk_score", 0), reverse=True)

        return [asdict(vuln) for vuln in vuln_list[:limit]]

    def _generate_compliance_summary(self, vulnerabilities: List[VulnerabilityModel]) -> Dict:
        """Generate compliance summary"""
        compliance_summary = {
            "hipaa": {"compliant": True, "violations": 0},
            "gdpr": {"compliant": True, "violations": 0},
            "pci_dss": {"compliant": True, "violations": 0}
        }

        for vuln in vulnerabilities:
            # Check for compliance violations
            if "phi" in vuln.title.lower() or "patient" in vuln.title.lower():
                compliance_summary["hipaa"]["violations"] += 1
                compliance_summary["hipaa"]["compliant"] = False

            if vuln.cvss_base_score and vuln.cvss_base_score >= 7.0:
                compliance_summary["gdpr"]["violations"] += 1
                compliance_summary["gdpr"]["compliant"] = False

            if "authentication" in vuln.title.lower() or "encryption" in vuln.title.lower():
                compliance_summary["pci_dss"]["violations"] += 1
                compliance_summary["pci_dss"]["compliant"] = False

        return compliance_summary

    def _generate_recommendations(self, vulnerabilities: List[VulnerabilityModel]) -> List[str]:
        """Generate recommendations based on vulnerability data"""
        recommendations = []

        # Analyze vulnerability patterns
        categories = {}
        for vuln in vulnerabilities:
            categories[vuln.category] = categories.get(vuln.category, 0) + 1

        # Top categories
        top_categories = sorted(categories.items(), key=lambda x: x[1], reverse=True)[:3]

        for category, count in top_categories:
            recommendations.append(f"Focus on {category} vulnerabilities ({count} found) - implement preventative controls")

        # SLA recommendations
        open_critical = len([v for v in vulnerabilities if v.severity == "critical" and v.status == "open"])
        if open_critical > 0:
            recommendations.append(f"Address {open_critical} open critical vulnerabilities immediately")

        # Compliance recommendations
        if any(v.metadata.get("risk_score", 0) > 8.0 for v in vulnerabilities):
            recommendations.append("Implement enhanced security controls for high-risk applications")

        return recommendations

    def _map_severity(self, severity: str) -> Priority:
        """Map string severity to Priority enum"""
        mapping = {
            "critical": Priority.CRITICAL,
            "high": Priority.HIGH,
            "medium": Priority.MEDIUM,
            "low": Priority.LOW,
            "info": Priority.INFO
        }
        return mapping.get(severity.lower(), Priority.MEDIUM)

    def _parse_cvss_score(self, cvss_data: Any) -> Optional[CVSSScore]:
        """Parse CVSS score data"""
        if isinstance(cvss_data, (int, float)):
            return CVSSScore(
                base_score=float(cvss_data),
                impact_score=float(cvss_data),
                exploitability_score=float(cvss_data)
            )
        elif isinstance(cvss_data, dict):
            return CVSSScore(
                base_score=cvss_data.get("base_score", 0.0),
                impact_score=cvss_data.get("impact_score", 0.0),
                exploitability_score=cvss_data.get("exploitability_score", 0.0),
                temporal_score=cvss_data.get("temporal_score"),
                environmental_score=cvss_data.get("environmental_score"),
                vector_string=cvss_data.get("vector_string")
            )
        return None

    def _db_model_to_vulnerability(self, db_vuln: VulnerabilityModel) -> Vulnerability:
        """Convert database model to Vulnerability object"""
        cvss_score = None
        if db_vuln.cvss_base_score:
            cvss_score = CVSSScore(
                base_score=db_vuln.cvss_base_score,
                impact_score=db_vuln.cvss_base_score,
                exploitability_score=db_vuln.cvss_base_score,
                vector_string=db_vuln.cvss_vector
            )

        return Vulnerability(
            id=db_vuln.id,
            title=db_vuln.title,
            description=db_vuln.description,
            severity=self._map_severity(db_vuln.severity),
            cvss_score=cvss_score,
            category=db_vuln.category,
            scanner=db_vuln.scanner,
            location=db_vuln.location,
            status=VulnerabilityStatus(db_vuln.status),
            first_detected=db_vuln.first_detected,
            last_detected=db_vuln.last_detected,
            affected_components=db_vuln.affected_components or [],
            remediation=db_vuln.remediation or "",
            assignee=db_vuln.assignee,
            due_date=db_vuln.due_date,
            jira_ticket=db_vuln.jira_ticket,
            tags=db_vuln.tags or [],
            metadata=db_vuln.metadata or {}
        )

    def _handle_vulnerability_regression(self, vulnerability: Vulnerability):
        """Handle vulnerability regression (re-occurrence of resolved vulnerability)"""
        self.logger.warning(f"Vulnerability regression detected: {vulnerability.id}")

        # Re-open the vulnerability
        session = self.db.get_session()
        try:
            db_vuln = session.query(VulnerabilityModel).filter_by(id=vulnerability.id).first()
            if db_vuln:
                db_vuln.status = "open"
                db_vuln.last_detected = datetime.now()
                session.commit()

                # Update JIRA ticket if exists
                if db_vuln.jira_ticket and self.jira_client:
                    try:
                        issue = self.jira_client.issue(db_vuln.jira_ticket)
                        issue.update(
                            summary=f"[REGRESSION] {issue.fields.summary}",
                            description=f"{issue.fields.description}\n\n---\n**REGRESSION DETECTED**\nThis vulnerability has re-appeared after being resolved.\n---\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)"
                        )
                        issue.add_label(value="regression")
                    except Exception as e:
                        self.logger.error(f"Failed to update JIRA ticket {db_vuln.jira_ticket}: {e}")

        except Exception as e:
            session.rollback()
            self.logger.error(f"Failed to handle vulnerability regression for {vulnerability.id}: {e}")
        finally:
            session.close()

def main():
    """Main function for vulnerability management system"""
    import argparse

    parser = argparse.ArgumentParser(description='HMS Enterprise Vulnerability Management')
    parser.add_argument('--config', '-c', default='devops/security/vulnerability-config.yaml',
                       help='Path to configuration file')
    parser.add_argument('--ingest', '-i', help='Ingest vulnerability findings from JSON file')
    parser.add_argument('--report', '-r', help='Generate vulnerability report (period in days)')
    parser.add_argument('--prioritize', '-p', action='store_true',
                       help='Prioritize existing vulnerabilities')

    args = parser.parse_args()

    # Initialize vulnerability manager
    vm = HMSVulnerabilityManager(args.config)

    if args.ingest:
        # Ingest vulnerability findings
        with open(args.ingest, 'r') as f:
            scan_results = json.load(f)
        vulnerabilities = vm.ingest_vulnerabilities(scan_results)
        prioritized_vulns = vm.prioritize_vulnerabilities(vulnerabilities)
        print(f"Ingested and prioritized {len(prioritized_vulns)} vulnerabilities")

    elif args.report:
        # Generate vulnerability report
        report = vm.generate_vulnerability_report(int(args.report))
        with open(f'vulnerability-report-{datetime.now().strftime("%Y%m%d")}.json', 'w') as f:
            json.dump(report, f, indent=2, default=str)
        print(f"Generated vulnerability report for {args.report} days")

    elif args.prioritize:
        # Prioritize existing vulnerabilities
        # Implementation for prioritizing existing vulnerabilities
        print("Prioritized existing vulnerabilities")

    else:
        print("HMS Enterprise Vulnerability Management System")
        print("Use --help for available commands")

if __name__ == "__main__":
    main()